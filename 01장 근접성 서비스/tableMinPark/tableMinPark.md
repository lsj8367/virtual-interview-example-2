## 1. 요구 사항 분석

- 기능 요구 사항
    - 주변 사업장 검색: 사용자 위치(위도/경도) 기준 반경 정보에 매치되는 사업장 목록 반환
    - 사업장 정보 관리:
        - 사업장 소유주 기준, 사업장 정보 CRUD
        - 검색 결과에 실시간 반영될 필요 없음
    - 사업장 상세 정보 조회: 사업장에 대한 상세 정보를 조회
- 비기능 요구 사항
    - 낮은 응답 지연: 주변 사업장을 신속히 검색이 가능해야 함
    - 데이터 보호: 사용자 위치는 민감한 정보 → 사용자 정보를 보호할 방법을 고려해야함
    - 고가용성 및 규모 확장성: 인구 밀집 지역에서 트래픽이 급증해도 감당가능한 시스템 설계 필요
- 개략적 규모 측정

    ```markdown
    QPS (Query per Second)
    특정 작업에 대한 요청이 초당 얼마나 처리되는지 나타내는 지표
    시스템의 성능과 처리 능력을 평가하는 중요한 측정 지표중 하나
    ```

    - 일간 능동 사용자 (DAU): 1억 명
    - 등록된 사업장 수: 2억 개
    - QPS (Query per Second) 계산:
        - 하루 = 86,400초 ~= 100,000초로 가정
        - 사용자당 하루 평균 5회 검색한다고 가정
        - QPS = (1억 명 x 5회) / 100,000초 = 5,000

---

## 2. 개략적 설계

- API 설계
    - 위치 기반 서비스 API
        - `GET /v1/search/nearby` : 주변 사업장 조회
    - 사업장 관리 API
        - `GET /v1/businesses/:id`: 특정 사업장 상세 정보 반환
        - `POST /v1/businesses`: 새로운 사업장 추가
        - `PUT /v1/businesses/:id`: 사업장 상세 정보 갱신
        - `DELETE /v1/businesses/:id`: 특정 사업장 정보 삭제
- 데이터 모델
    - 읽기 비율이 높은 서비스, 관계형 데이터 베이스가 적합
    - 스키마 설계
        - **`business` 테이블**: `business_id` (PK), `address`, `city`, `latitude`, `longitude` 등 사업장 상세 정보를 저장
        - **`geospatial_index` 테이블**: 위치 정보 검색 효율을 높이기 위한 색인 테이블
- 개략적 설계도
    - 로드벨런서: 트래픽을 URL 경로에 따라 LBS 또는 사업장 서비스로 분산
    - 위치 기반 서비스 (LBS)
        - 주변 사업장 조회 요청을 처리
        - QPS 가 높음
        - 무상태 서비스 → 수평적 확장이 용이
    - 사업장 서비스
        - 사업장 관리 요청을 처리
        - QPS 는 낮지만, 특정 시간대 높을 수 있음
    - 데이터베이스 클러스터
        - 주 데이터베이스: 쓰기 요청 처리 (사업장 서비스)
        - 사본 데이터베이스: 읽기 요청을 처리 (LBS, 사업장 서비스에서 사용)
        - 데이터는 주 DB 에서 사본 DB 로 복제
        - 실시간 갱신이 필요 없으므로 복제 지연은 허용

---

## 3. 위치 검색 알고리즘

- 2차원 검색

    ```sql
    SELECT business_id, latitude, longitude,
      FROM business
     WHERE 1=1
       AND (latitude  BETWEEN {:my_lat)  - radius AND {:my_lat)  + radius)
       AND (Longitude BETWEEN {:my_long} - radius AND {:my_long} + radius)
    ```

    - 문제점
        - 테이블 데이터를 전부 읽어야 함 (비효율적)
        - 위도와 경도에 각각 인덱스가 있어도, DB는 두 개의 큰 데이터 집합(데이터 집합 1, 2)을 가져와 교집합을 구해야 하므로 매우 비효율적
- 균등 격자
    - 지도를 동일한 크기의 격자로 나눔
    - **문제점**
        - 사업장 분포가 균등하지 않아(도심 vs 사막), 데이터가 특정 격자에 몰리게 됨
        - 주어진 격자의 인접한 격자를 찾기 까다로움
- 지오해시
    - 2차원의 위도/경도를 1차원의 문자열로 변환하는 기술
    - 문자열이 길어질수록 더 정밀한 격자를 의미함
    - 검색 반경을 덮는 최소 크기의 격자를 만들도록 지오해시 길이를 정함
    - 문제점
        - 격자 가장자리 이슈
            - 매우 가까운 두 지점이 완전히 다른 지오해시 값을 가질 수 있음
            - 검색 반경 원이 여러 격자에 걸칠 수 있음
    - 해결방안
        - 격자 가장자리 이슈
            - 현재 위치가 포함된 격자 뿐만 아니라, 인접한 8개의 격자를 포함하여 9개의 격자를 기준으로 검색
            - 결과가 부족할 경우에는 지오 해시의 마지막 비트를 지워 더 넓은 상위 격자에서 다시 검색하여 검색 범위를 넓힘
- 쿼드트리
    - 2차원 공간을 재귀적으로 4개의 사분면(자식노드)으로 분할하는 트리 자료구조
    - 특정 노드의 사업장 수가 100개 이하가 될 때까지 분할
    - 데이터 베이스가 아닌, 각 LBS 서버에 구축되는 메모리 기반 자료구조
    - 인구 밀집 지역은 잘게, 아닌 지역은 크게 격자 크기를 동적으로 조절이 가능
    - 서버 시작 시, 트리 구축 시간이 소요
    - 트리 갱신 작업이 복잡하고, 다중 스레드 환경인 경우 락 메커니즘이 필요
- 구글 S2
    - 구글 지오메트리 라이브러리로, 지구를 힐베르트 곡선을 사용해 1차원 색인화
    - 지오펜스 구현에 적합

- 위치 검색 알고리즘 비교
    - 지오해시는 구현이 쉽고, 색인 갱신이 간단 (단순 DB 레코드 추가/삭제)
    - 쿼드트리는 가장 가까운 K 개 검색이 유리하고, 인구 밀도에 따른 동적 분할이 가능한 구조이지만, 구현과 갱신이 복잡

---

## 4. 상세 설계

- 데이터베이스 규모 확장성
    - **`business` 테이블**
        - 데이터가 한 서버에 다 담기지 않을 수 있으므로, 샤딩이 필요할 수 있음
        - **`business_id`** 를 기준으로 샤딩하는 것이 가장 간단하고 부하를 고르게 분산시킬 수 있음
    - **`geospatial_index` 테이블**
        - `(geohash, business_id)`를 한 쌍으로 하는 레코드를 저장
- 캐시
    - 캐시키
        - 사용자의 위도/경도 값은 계속 미세하게 변동이 있으므로, 캐시키로는 부적합
        - 특정 격자 영역을 나타내는 지오해시를 캐시키로 사용하는 것이 적합
    - 캐시 데이터 유형
        - 지오해시 캐시
            - key: `geohash`
            - value: `List<Business>`
        - 사업장 정보 캐시
            - key: `business_id`
            - value: `Business`
    - 캐시 갱신 주기
        - 사업장 정보는 자주 변경되지 않으므로(일 배치성으로 다음날 반영), DB 갱신 시 캐시를 무효화 함.
        - 요구 사항에 따라 밤 사이에 캐시를 갱신할수도 있음
- 지역 및 가용성 구역
    - 시스템을 전 세계 여러 지역 및 가용성 구역에 설치
    - 기대 효과
        - 지연 시간 감소: 물리적으로 가까운 서버로 요청을 하여 지연 시간이 상대적으로 감소
        - 부하 분산: 인구 밀도가 높은 지역에는 별도의 리전을 두어 트래픽을 분산 시킴
        - 법규 준수: 지역별 다른 사생활 법령을 준수하기 위해 별도 처리가 가능

---

### 기타 사항

- 소비자 재조정으로 인한 서비스 중단
  - 새로운 소비자가 합류하거나 이탈할 때, 코디네이터는 그룹 내의 모든 솝자에게 재합류를 요청하고 ㄹ더가 새 파티션 계획을 분배함
  - 문제: 재조정을 하는 중에 해당 소비자 그룹 전체가 일시적으로 메시지 소비를 중단 해야 하는 문제가 발생하지 않을까?
  - 해결: 전체 파티션을 재할당하는 대신, 변경되는 파티션만 점진적으로 재조정하는 방식으로 진행하면 좋을 것 같음

- 브로커 기반 메시지 필터링
  - 태그를 사용하여 브로커에서 메시지를 필터링 하는 기능을 제안함
  - 문제: 필터링 조건이 다양해지면, 브로커에 큰 부하를 줄 수 있고 이후 데이터 전송에 영향이 있을 수 있음
  - 해결: 브로커는 단순히 데이터만 전달하고, 이후 Spring AOP 와 같은 것을 활용하여 공통적으로 태그를 처리할 수 있는 모듈을 개발 하는 것이 로직 공통화, 유지보수성 향상에도 도움이 될 것 같음 