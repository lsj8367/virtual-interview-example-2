## 분산 메시지 큐란?

현대적 소프트웨어 아키텍처에서 시스템 내 작고 독립적인 블록(컴포넌트) 사이의 **통신과 조율을 담당하는 시스템**

### 메시지 큐의 이점

* **결합도 완화 (Decoupling):** 컴포넌트 간 강한 결합이 사라져 독립적으로 갱신 가능
* **규모 확장성 개선:** 트래픽 부하에 맞춰 생산자(Producer)와 소비자(Consumer) 규모를 독립적으로 조절 가능
* **가용성 개선:** 특정 컴포넌트에 장애가 발생해도 다른 컴포넌트는 큐와 계속 상호작용 가능
* **성능 개선:** 비동기 통신이 가능해져, 생산자와 소비자가 서로 기다릴 필요 없음

---

## 메시지 큐 vs 이벤트 스트리밍 플랫폼

| 구분 | 전통적 메시지 큐 (예: RabbitMQ) | 이벤트 스트리밍 플랫폼 (예: Kafka) |
| :--- |:------------------------|:-----------------------|
| **데이터 보관** | 메시지 전달에 충분한 기간만 메모리에 보관 | **데이터 장기 보관** (예: 2주)  |
| **메시지 소비** | 한 소비자가 가져가면 큐에서 삭제      | **메시지 반복 소비** 가능       |
| **메시지 순서** | 보통 보증하지 않음              | 생산된 순서대로 소비 가능 (FIFO)  |

---

## 용어 정리

| 용어 | 설명                                                               |
| :--- |:-----------------------------------------------------------------|
| **생산자 (Producer)** | 메시지를 메시지 큐(토픽)에 발행하는 클라이언트                                       |
| **소비자 (Consumer)** | 큐(토픽)를 구독하고 메시지를 꺼내어 소비하는 클라이언트                                  |
| **브로커 (Broker)** | 메시지 큐 클러스터 내의 서버. 파티션을 유지 관리                                     |
| **토픽 (Topic)** | 메시지를 주제별로 정리(분류)하는 데 사용                                          |
| **파티션 (Partition)** | 토픽을 여러 개로 분할한 것 (샤딩). 토픽 용량 확장의 비결이며, 각 파티션은 FIFO 큐처럼 동작         |
| **오프셋 (Offset)** | 파티션 내에서 메시지의 상대적인 위치를 나타내는 값                                     |
| **소비자 그룹 (Consumer Group)** | 하나 이상의 토픽을 구독하고 메시지를 소비하기 위해 협력하는 소비자들의 집합                       |
| **조정 서비스 (Coordination Service)** | 브로커 클러스터의 조정을 담당 (예: 주키퍼). 서비스 탐색, 리더 선출 등의 역할을 수행               |
| **코디네이터 (Coordinator)** | 소비자 그룹의 조정 작업을 전담하는 브로커, 소비자 재조정을 관리하고 오프셋 정보를 관리 (조정 서비스와 다름) |

---

## 메시지 모델

### 1. 일대일 (Point-to-Point) 모델
* 큐에 전송된 메시지는 **오직 하나의 소비자**만 가져갈 수 있음
* 소비자가 메시지를 가져갔다고 알리면(acknowledge) 메시지는 큐에서 삭제
* 본 설계안에서는 모든 소비자를 같은 소비자 그룹에 두어 일대일 모델 구현 가능

### 2. 발행-구독 (Pub-Sub) 모델
* 토픽(Topic) 개념을 사용
* 토픽에 전달된 메시지는 해당 토픽을 구독하는 모든 소비자에게 전달

---

## 소비자 측 동작 방식

### 푸시 (Push) vs. 풀 (Pull) 모델

| 모델 | 동작 방식               | 장점                                | 단점                                                    |
| :--- |:--------------------|:----------------------------------|:------------------------------------------------------|
| **푸시 (Push)** | 브로커가 소비자에게 데이터를 전달  | 낮은 지연, 메시지를 받는 즉시 전송 가능           | 소비자가 처리 속도보다 빠르게 메시지를 받아 과부하가 걸릴 수 있음                 |
| **풀 (Pull)** | 소비자가 브로커로부터 데이터를 당김 | 소비자가 스스로 메시지 소비 속도를 결정, 일괄 처리에 적합 | 메시지가 없을 때도 계속 폴링(polling)하여 자원이 낭비될 수 있음 (롱 폴링으로 극복) |

> **설계 선택:** 대부분의 메시지 큐는 **풀(Pull) 모델**을 지원

### 소비자 재조정 (Consumer Rebalancing)
* **정의:** 어떤 소비자가 어떤 파티션을 담당할지 다시 정하는 프로세스
* **발생 시점:** 새로운 소비자가 그룹에 합류하거나, 기존 소비자가 떠나거나, 소비자에게 장애가 발생할 때 시작
* **동작:** 소비자에게 장애가 발생해 박동(heartbeat) 메시지가 끊기면, 코디네이터가 이를 감지하고 재조정 프로세스를 시작

---

## 데이터 저장 및 복제

### 1. 데이터 저장소: 쓰기 우선 로그 (WAL)
데이터베이스는 빈번한 대규모 읽기/쓰기 동시 처리에 적합하지 않아 병목이 될 수 있음

* **선택:** 쓰기 우선 로그(Write-Ahead Log, WAL)를 사용
* **특징:**
    * 새로운 항목이 추가되기만 하는(append-only) 파일
    * 디스크 접근 패턴이 순차적이라 매우 좋은 성능
* **세그먼트 (Segment):**
    * 로그 파일이 무한정 커질 수 없으므로 세그먼트 단위로 나눔
    * 새 메시지는 활성 세그먼트에만 추가
    * 활성 세그먼트가 한계에 도달하면 비활성 상태가 되며 읽기 요청만 처리

### 2. 복제 (Replication)
장애 감내와 높은 가용성을 위해 데이터를 복제

* **리더 (Leader):** 각 파티션의 사본 중 하나는 리더가 됨, 생산자는 오직 리더에게만 메시지를 전송
* **단순 사본 (Follower):** 리더가 아닌 사본이며, 리더로부터 새 메시지를 가져와 동기화

### 3. 동기화된 사본 (In-Sync Replicas, ISR)
* **정의:** 리더와 동기화된 상태를 유지하고 있는 사본들의 집합 (리더는 항상 ISR에 포함)
* **존재 이유:** 성능과 영속성 사이의 타협점, 모든 사본이 동기화될 때까지 기다리면(ACK=all) 가장 안전하지만, 하나의 느린 사본이 전체를 느리게 만들 수 있음.
* **합의 오프셋 (Committed Offset):** 이 오프셋 값은 "ISR 집합 내 모든 사본"에 동기화가 완료되었음을 의미하는 위치

---

## 메시지 전달 방식 (Semantics)

생산자는 **ACK 설정**을 통해 영속성과 응답 지연 사이의 균형을 맞출 수 있음

* **ACK=all (또는 -1):** 모든 ISR이 메시지를 수신한 뒤 ACK 응답을 받음, 영속성은 가장 높지만 응답 시간이 길어짐
* **ACK=1:** 리더가 메시지를 저장하면 바로 ACK 응답을 받음, 응답 지연은 개선되지만, 리더 장애 시 메시지가 소실될 수 있음
* **ACK=0:** ACK 응답을 기다리지 않음, 응답 지연은 가장 낮지만 메시지 손실 위험 존재

### 1. 최대 한 번 (At-most-once)
* 메시지가 소실될 수는 있지만, 중복 전달은 없음
* **생산자:** `ACK=0`을 사용하고 재시도하지 않음
* **소비자:** 메시지를 처리하기전에 오프셋을 갱신

### 2. 최소 한 번 (At-least-once)
* 메시지 소실은 없지만, 중복 전달이 발생할 수 있음
* **생산자:** `ACK=1` 또는 `ACK=all`을 사용하고, 실패 시 계속 재시도
* **소비자:** 메시지를 성공적으로 처리한후에만 오프셋을 갱신

### 3. 정확히 한 번 (Exactly-once)
* 구현하기 가장 까다로운 방식
* 메시지가 정확히 한 번만 전달되는 것을 보장하며, 주로 금융 관련 응용에 적합

---

## 고급 기능

* **메시지 필터링:** 소비자가 토픽의 모든 메시지를 받는 대신, 원하는 메시지만 받도록 하는 기능, 메시지 페이로드(내용)가 아닌 메타데이터 영역에 태그(Tag)를 두어 브로커가 효율적으로 필터링하도록 구현할 수 있음
* **지연/예약 전송:** 메시지를 즉시 토픽에 저장하지 않고, **임시 저장소**에 보관했다가 지정된 시간이 되면 토픽으로 전송하는 기능 (예: 주문 30분 후 결제 확인)

---

### 기타 사항

- 소비자 재조정으로 인한 서비스 중단
  - 새로운 소비자가 합류하거나 이탈할 때, 코디네이터는 그룹 내의 모든 솝자에게 재합류를 요청하고 ㄹ더가 새 파티션 계획을 분배함
  - 문제: 재조정을 하는 중에 해당 소비자 그룹 전체가 일시적으로 메시지 소비를 중단 해야 하는 문제가 발생하지 않을까?
  - 해결: 전체 파티션을 재할당하는 대신, 변경되는 파티션만 점진적으로 재조정하는 방식으로 진행하면 좋을 것 같음

- 브로커 기반 메시지 필터링
  - 태그를 사용하여 브로커에서 메시지를 필터링 하는 기능을 제안함
  - 문제: 필터링 조건이 다양해지면, 브로커에 큰 부하를 줄 수 있고 이후 데이터 전송에 영향이 있을 수 있음
  - 해결: 브로커는 단순히 데이터만 전달하고, 이후 Spring AOP 와 같은 것을 활용하여 공통적으로 태그를 처리할 수 있는 모듈을 개발 하는 것이 로직 공통화, 유지보수성 향상에도 도움이 될 것 같음